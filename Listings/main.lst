C51 COMPILER V9.59.0.0   MAIN                                                              05/01/2025 17:55:27 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE user\main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\driver\inc;.\device\inc) D
                    -EBUG OBJECTEXTEND PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "STC15F2K60S2.H"
   2          #include "ds18b20.h"
   3          #include "smg.h"
   4          #include "pcf8591.h"
   5          #include "hc573.h"
   6          #include "key.h"
   7          #include "led.h"
   8          #include "relay.h"
   9          #include "timer.h"
  10          #include "delay.h"
  11          #include "utralsound.h"
  12          
  13          unsigned char smgpos_index = 0;
  14          unsigned int sys_ticks = 0;
  15          
  16          unsigned char show_mode = 0;   /*0 env_state 1 sport_state 2 temprg_state  3 nc_state  10 距离参数*/
  17          unsigned char light_drgree = 1; /**光照等级 */
  18          bit distance_state_show_mode = 0;
  19          
  20          float tempture = 0.0;
  21          unsigned int distance = 0;
  22          unsigned int distance_pre = 0;
  23          unsigned int distance_now = 0;
  24          unsigned char sport_state = 1;
  25          unsigned char sport_state_pre = 1;
  26          
  27          
  28          unsigned char distance_prg = 30;
  29          unsigned char temp_prg = 20;
  30          unsigned int realy_count = 0; /**继电器吸合次数 */
  31          
  32          
  33          /**状态控制数组，下标表示对应的位置，如下标为0表示对应的0号数码管 ,默认均
             -为关闭状态*/
  34          /** 不要char Led_Buf[8]={1}直接初始化整个数组为1，测试发现不行 应该是C51不支持？
             -存疑中*/
  35          unsigned char Led_Buf[8] = {0, 0, 0,0,0,0,0,0};
  36          unsigned char Smg_Buf[8] = {20, 20, 20, 20,20, 20, 20, 20};   /**OFF */
  37          unsigned char Smg_Point[8] = {0, 0, 0,0,0,0,0,0};
  38          
  39          
  40          
  41          void show_process(void);
  42          void data_process(void);
  43          void key_process(void);
  44          void ledrelay_process(void);
  45          
  46          void Sys_Init(void)
  47          {
  48   1          P0 = 0xff;
  49   1          SelectHC573(CS_LED);
  50   1          P2 &= 0x1F;  //关闭LED
  51   1          
  52   1          P0 = 0x00;   //关蜂鸣器，继电器 步进电机
C51 COMPILER V9.59.0.0   MAIN                                                              05/01/2025 17:55:27 PAGE 2   

  53   1          SelectHC573(CS_ULN2003);
  54   1           P2 &= 0x1F;
  55   1          
  56   1      }
  57          
  58          
  59          int main()
  60          {
  61   1          bit first_read = 1;
  62   1          unsigned char i;
  63   1          Timer1_Init();
  64   1          Sys_Init();
  65   1      
  66   1          tempture = read_tempture(first_read);
  67   1          first_read = 0;
  68   1          
  69   1          while(1) {
  70   2              if (sys_ticks % 1000 == 0) {
  71   3                  distance_now = us_data();
  72   3                  distance = distance_now - distance_pre;
  73   3                  distance_pre = distance_now;
  74   3              }
  75   2              data_process();
  76   2              show_process();
  77   2              ledrelay_process();
  78   2              key_process();
  79   2          }
  80   1      }
*** WARNING C280 IN LINE 62 OF user\main.c: 'i': unreferenced local variable
  81          
  82          
  83          void show_process(void)
  84          {
  85   1          switch(show_mode) {
  86   2              case 0:  /**0 env_state */
  87   2                  Smg_Buf[0] = 12;  /*c*/
  88   2                  Smg_Buf[1] = ((int)tempture) /10;
  89   2                  Smg_Buf[2] = ((int)tempture) %10;
  90   2                  Smg_Buf[3] = 20;
  91   2                  Smg_Buf[4] = 20;
  92   2                  Smg_Buf[5] = 20;
  93   2                  Smg_Buf[6] = 18;  /*n*/  
  94   2                  Smg_Buf[7] = light_drgree;
  95   2              break;
  96   2      
  97   2              case 1:  /* 运动检测状态  显示超声波测量的距离 单位 cm*/
  98   2                  Smg_Buf[0] = 16;  /**L */
  99   2                  Smg_Buf[1] = sport_state;
 100   2                  Smg_Buf[2] = 20;
 101   2                  Smg_Buf[3] = 20;
 102   2                  Smg_Buf[4] = 20;
 103   2                  Smg_Buf[5] = distance_now / 100;
 104   2                  Smg_Buf[6] = distance_now / 10 % 10;
 105   2                  Smg_Buf[7] = distance_now % 10;
 106   2              break;
 107   2      
 108   2              case 2:  /**温度参数界面 */
 109   2                  Smg_Buf[0] = 17;  /**P */
 110   2                  Smg_Buf[1] = 12;  /**C */
 111   2                  Smg_Buf[2] = 20;
 112   2                  Smg_Buf[3] = 20;
 113   2                  Smg_Buf[4] = 20;
C51 COMPILER V9.59.0.0   MAIN                                                              05/01/2025 17:55:27 PAGE 3   

 114   2                  Smg_Buf[5] = 20;
 115   2                  Smg_Buf[6] = temp_prg / 10;
 116   2                  Smg_Buf[7] = temp_prg % 10;
 117   2              break;
 118   2      
 119   2      
 120   2              case 3: /**数据统计状态 */
 121   2                  Smg_Buf[0] = 18; /**n */
 122   2                  Smg_Buf[1] = 12; /**c */
 123   2                  Smg_Buf[2] = 20;
 124   2                  Smg_Buf[3] = 20;
 125   2                  Smg_Buf[4] = (((realy_count / 1000) == 0) ? 20 : (realy_count / 1000));
 126   2                  if (Smg_Buf[4] != 20) {  /**最高位不为0 但第二位为0 例如10xx这种 */
 127   3                      Smg_Buf[5] = (((realy_count % 1000 / 100) == 0) ? 0 : (realy_count % 1000 / 100));
 128   3                  }else {
 129   3                      Smg_Buf[5] = (((realy_count % 1000 / 100) == 0) ? 20 : (realy_count % 1000 / 100));
 130   3                  }
 131   2      
 132   2                  if (Smg_Buf[5] != 20) {  /**20x这种情况 */
 133   3                      Smg_Buf[6] = (((realy_count % 100 / 10) == 0) ? 0 : (realy_count % 100 / 10));
 134   3                  }else {
 135   3                      Smg_Buf[6] = (((realy_count % 100 / 10) == 0) ? 20 : (realy_count % 100 / 10));
 136   3                  }
 137   2                 
 138   2                  if (Smg_Buf[6] != 20) {  
 139   3                      Smg_Buf[7] = (((realy_count % 10 ) == 0) ? 0 : (realy_count % 10 ));
 140   3                  }else {
 141   3                      Smg_Buf[7] = (((realy_count % 10) == 0) ? 20 : (realy_count % 10 ));
 142   3                  }
 143   2              break;
 144   2      
 145   2              case 10:
 146   2                  Smg_Buf[0] = 17;  /**P */
 147   2                  Smg_Buf[1] = 16;  /**L */
 148   2                  Smg_Buf[2] = 20;
 149   2                  Smg_Buf[3] = 20;
 150   2                  Smg_Buf[4] = 20;
 151   2                  Smg_Buf[5] = 20;
 152   2                  Smg_Buf[6] = distance_prg / 10;
 153   2                  Smg_Buf[7] = distance_prg % 10;
 154   2              break;
 155   2          }
 156   1      }
 157          
 158          
 159          void data_process(void)
 160          {
 161   1          unsigned char vol_temp;
 162   1      
 163   1          if (sys_ticks % 200 != 0) {
 164   2              return;
 165   2          }
 166   1      
 167   1          #if 0
                  if (sys_ticks % 100 == 0) {   /**1s内采10次超声波 */
                          distance = us_data();
                          vol_temp = PCF8591_Read(PCF8591_CH1);  /**读光敏电阻 51份为1v*/
                      }
                      if (sys_ticks % 500 == 0) {
                          tempture = read_tempture(0);
                  }
                  #endif
C51 COMPILER V9.59.0.0   MAIN                                                              05/01/2025 17:55:27 PAGE 4   

 176   1      
 177   1          //distance = us_data();
 178   1          vol_temp = 255 - PCF8591_Read(PCF8591_CH1);  /**读光敏电阻 51份为1v*/
 179   1          tempture = read_tempture(0);
 180   1          if (vol_temp  >= 3*51) {
 181   2              light_drgree = 1;
 182   2          } else if (vol_temp >= 2*51 && vol_temp < 3*51) {
 183   2              light_drgree = 2;
 184   2          }else if (vol_temp >= 25 && vol_temp < 2*51){
 185   2              light_drgree = 3;
 186   2          }else {
 187   2              light_drgree = 4;
 188   2          }
 189   1      
 190   1      }
 191          
 192          void key_process(void)
 193          {
 194   1          static unsigned char Key_Val, Key_Down, Key_Up, Key_Old;
 195   1          static unsigned int systick_current = 0;
 196   1          static unsigned int systick_pre = 0;
 197   1          if(sys_ticks % 10) {  
 198   2              return; 
 199   2          }
 200   1          
 201   1          //Key_Val = Key_Matrix_Scan(0);
 202   1          Key_Val = Key_Matrix_Scan();
 203   1      
 204   1          /**官方提供的消抖代码 */
 205   1          Key_Down = Key_Val & (Key_Old ^ Key_Val);
 206   1              Key_Up = ~Key_Val & (Key_Old ^ Key_Val);
 207   1              Key_Old = Key_Val;
 208   1      
 209   1          if (Key_Down == KEY_S4) { 
 210   2              if( 10 == show_mode) show_mode = 3;
 211   2              else {
 212   3                  show_mode++;
 213   3                  if (4 == show_mode) show_mode = 0;
 214   3              }
 215   2          }
 216   1      
 217   1          if (Key_Down == KEY_S5 ) {  /**进入参数子界面 */
 218   2              if (show_mode == 2) {
 219   3                  show_mode = 10; /**进入距离参数界面 */
 220   3                  return;
 221   3              }
 222   2              if (show_mode == 10) {
 223   3                  show_mode = 2; /**进入温度参数界面 */
 224   3              }
 225   2          }
 226   1      
 227   1      
 228   1          if (Key_Down == KEY_S8) {  //+
 229   2              if(show_mode == 2) {  //温度参数模式
 230   3                  temp_prg = (temp_prg == 80) ? 80 : (temp_prg + 1); 
 231   3              }else if (show_mode == 10) { //距离参数模式
 232   3                  distance_prg = (distance_prg == 80) ? 80 : (distance_prg + 5);
 233   3              }
 234   2          }
 235   1      
 236   1          if (Key_Down == KEY_S9) {  //-
 237   2              if(show_mode == 2) {  //温度参数模式
C51 COMPILER V9.59.0.0   MAIN                                                              05/01/2025 17:55:27 PAGE 5   

 238   3                  temp_prg = (temp_prg == 20) ? 20 : (temp_prg - 1); 
 239   3              }else if (show_mode == 10) { //距离参数模式
 240   3                  distance_prg = (distance_prg == 20) ? 20 : (distance_prg - 5);
 241   3              }
 242   2          }
 243   1      
 244   1          if (Key_Down == 89)  {
 245   2              if (show_mode == 3) {
 246   3                  systick_current = sys_ticks;  //记录当前ticks
 247   3                  if (systick_current - systick_pre >= 2000 || (3000 - systick_pre) + systick_current >=2000) {
 248   4                      realy_count = 0;
 249   4                  }
 250   3                  systick_pre = systick_current;
 251   3              }
 252   2          }
 253   1      }
 254          
 255          
 256          /**
 257           * @brief 根据显示模式处理 LED 和继电器的状态
 258           *
 259           * 该函数根据全局变量 show_mode 的值，对不同的显示模式进行不同的 LED 和继电器
             -控制操作。
 260           */
 261          void ledrelay_process(void)
 262          {
 263   1          static bit relay_flag = 1; /**继电器吸合标志位 */
 264   1          if (distance_now < distance_prg) {  //距离值小于距离参数，全部熄灭
 265   2              Led_Buf[0] = LED_OFF;
 266   2              Led_Buf[1] = LED_OFF;
 267   2              Led_Buf[2] = LED_OFF;
 268   2              Led_Buf[3] = LED_OFF;
 269   2          }else {
 270   2              switch(light_drgree) {
 271   3                  case 1:
 272   3                      Led_Buf[0] = LED_ON;
 273   3                      Led_Buf[1] = LED_OFF;
 274   3                      Led_Buf[2] = LED_OFF;
 275   3                      Led_Buf[3] = LED_OFF;
 276   3                      Led_Buf[4] = LED_OFF;
 277   3                      Led_Buf[5] = LED_OFF;
 278   3                      Led_Buf[6] = LED_OFF; 
 279   3                  break;
 280   3      
 281   3                  case 2:
 282   3                      Led_Buf[0] = LED_ON;
 283   3                      Led_Buf[1] = LED_ON;
 284   3                      Led_Buf[2] = LED_OFF;
 285   3                      Led_Buf[3] = LED_OFF;
 286   3                      Led_Buf[4] = LED_OFF;
 287   3                      Led_Buf[5] = LED_OFF;
 288   3                      Led_Buf[6] = LED_OFF;
 289   3                      
 290   3                  break;
 291   3      
 292   3                  case 3:
 293   3                      Led_Buf[0] = LED_ON;
 294   3                      Led_Buf[1] = LED_ON;
 295   3                      Led_Buf[2] = LED_ON;
 296   3                      Led_Buf[3] = LED_OFF;
 297   3                      Led_Buf[4] = LED_OFF;
 298   3                      Led_Buf[5] = LED_OFF;
C51 COMPILER V9.59.0.0   MAIN                                                              05/01/2025 17:55:27 PAGE 6   

 299   3                      Led_Buf[6] = LED_OFF;
 300   3                      
 301   3                  break;
 302   3      
 303   3                  case 4:
 304   3                      Led_Buf[0] = LED_ON;
 305   3                      Led_Buf[1] = LED_ON;
 306   3                      Led_Buf[2] = LED_ON;
 307   3                      Led_Buf[3] = LED_ON;
 308   3                      Led_Buf[4] = LED_OFF;
 309   3                      Led_Buf[5] = LED_OFF;
 310   3                      Led_Buf[6] = LED_OFF;
 311   3                      
 312   3                  break;
 313   3              }
 314   2          }
 315   1      
 316   1          if (distance < 5) {
 317   2              Led_Buf[7] = LED_OFF;
 318   2              sport_state_pre = sport_state;
 319   2              sport_state = 1;
 320   2          }else if (distance >=5 && distance <  10){
 321   2              Led_Buf[7] = LED_ON;
 322   2              sport_state_pre = sport_state;
 323   2              sport_state = 2;
 324   2          }else {
 325   2              if (sys_ticks % 100 == 0) {
 326   3                  Led_Buf[7] = !Led_Buf[7];
 327   3                  sport_state_pre = sport_state;
 328   3                  sport_state = 3;
 329   3              }
 330   2          }
 331   1          
 332   1          /**继电器状态判定 */ 
 333   1          if ((distance_now < distance_prg) && tempture > temp_prg) {
 334   2              relay_ctrl(1);
 335   2              if (1 == relay_flag) {/**如果继电器本来已经吸合了，不用再加次数 */
 336   3                  realy_count++;
 337   3                  relay_flag = 0;
 338   3              }
 339   2          }else {
 340   2              relay_ctrl(0);
 341   2              relay_flag = 1;
 342   2          }
 343   1      }
 344          
 345          
 346          /**
 347           * @brief 定时器1中断服务函数
 348           *
 349           * 该函数在定时器1产生中断时被调用，用于处理系统的定时任务，
 350           * 包括更新系统时钟滴答、数码管显示、LED显示和继电器控制等。
 351           *
 352           * @param 无
 353           * @return 无
 354           */
 355          void Timer1_Handler(void) interrupt 3
 356          {
 357   1          sys_ticks=(++sys_ticks) % 5000;
 358   1      
 359   1          smgpos_index = (++smgpos_index) % 8;
 360   1          smg_display(smgpos_index, Smg_Buf[smgpos_index], Smg_Point[smgpos_index]);
C51 COMPILER V9.59.0.0   MAIN                                                              05/01/2025 17:55:27 PAGE 7   

 361   1          led_display(smgpos_index, Led_Buf[smgpos_index]);
 362   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1309    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     53       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
